---
title: "Assignment1"
output: html_document
date: "2025-10-08"
---
```{r}
# Clear plots
if(!is.null(dev.list())) dev.off()

# Clean workspace
rm(list=ls())
```



# 1. Data preparation
```{r}
# Loading data
df <- read.csv("RealEstate_Georgia.csv", header=T)

# Converting the data column to numeric
df$datePostedString <- as.Date(df$datePostedString, format = "%Y-%m-%d")
df$datePostedString <- as.numeric(format(df$datePostedString, format = "%Y"))

length(df[which(df$datePostedString == 2021),]$datePostedString)
df <- df[which(df$datePostedString == 2021),]

# Duplicate quick inspection
dup_rows <- duplicated(df$id) | duplicated(df$id, fromLast = TRUE)
dups_df  <- df[dup_rows, ][order(df$id[dup_rows]), ]
head(dups_df, 20)
```
**Problem:** 
1) Same information for all variables but different `countyId`. Since the variable `county` shows the same value for duplicated instances, `countyId` (5) will be removed due to the inconsistencies. If a numerical representation is needed, we will provide one. 

```{r}

# Columns to compare (exclude ids and countyId) without dropping them from df
cols_idx <- setdiff(seq_along(df), c(1:3, 5))

## Comparison by id (which columns differ between duplicates)
by_id <- split(dups_df[, cols_idx, drop = FALSE], dups_df$id)

diffs_list <- lapply(by_id, function(sub) {
  difs <- vapply(sub, function(x) length(unique(x)) > 1, logical(1))
  names(difs)[difs]              # solo las columnas que cambian
})

summary_df <- data.frame(
  id       = names(diffs_list),
  n_diff   = lengths(diffs_list),
  diff_vars = ifelse(lengths(diffs_list) == 0, "None",
                     vapply(diffs_list, function(x) paste(x, collapse = ", "), character(1))),
  stringsAsFactors = FALSE
)

table(summary_df$n_diff)                               # 0, 1, 2, 3...
sort(table(summary_df$diff_vars), decreasing = TRUE)   # combos: "countyId", "countyId, price", etc.

```
**Problem:** 
Case 1) Same information for all variables but different `countyId` (None group): select one of the two duplicates.
Case 2) Some observations have different information for some variables: check those carefully

```{r}
# Case 1
ids_none <- summary_df$id[summary_df$diff_vars == "None"]
keep_idx <- ifelse(df$id %in% ids_none, !duplicated(df$id), TRUE)
df <- df[keep_idx, ]
sum(duplicated(df$id) & df$id %in% ids_none)  

```
```{r}
# Case 2
summary_rest <- summary_df[summary_df$diff_vars != "None", ]
sort(table(summary_rest$diff_vars), decreasing = TRUE)

## helper: function to see all rows for a given combination
see_comb <- function(combo_str) {
  ids <- summary_rest$id[summary_rest$diff_vars == combo_str]
  out <- df[df$id %in% ids, ]
  out[order(out$id), ]
}

# Example of use:
see_comb("time, price, pricePerSquareFoot") 
```
Function 'see_comb' allows us to watch the duplicates for the different combinations of differences they have (for example, observations with different description, different value for garageSpaces...)

After analyzing all combinations of duplicates, the conclusions we have reached are the following:

  * Observations with different description: Since they have the same values for everything else, and the description is not a relevant variable, one of the two duplicates will be selected.
  
  * Observations with combinations of different time+event, time+price: Having checked all observations, it is confirmed that the duplicates correspond to price or event changes. The most recent observations are the ones to retain, since they contain the most recent information.
      ** One particular observation of this case also includes a modification in description, garageSpaces, hasGarage. Since the description hints that the Garage has been renovated to a basement, the most recent observation is also the one to include. 
  
  * One observation with different value for 'garageSpaces': since 'garage' has value 1 for both observations, we conclude the reliable description is the one where 'garageSpaces' is 1, not the one with value 0.
  
  * One observation with different value for 'parking': Since there is no reasonable way to find out which is the correct observation (value 0 or 1), the decision is to remove both duplicates, so as to not work with incorrect information.
  
  *One observation time, price, pricePerSquareFoot, description, garageSpaces, hasGarage"
  

### Duplicate removal
```{r}
## We start from:
## - df  (already deduped for "None" cases)
## - summary_rest = subset of summary_df where diff_vars != "None"

## ---- Identify ids by rule ----
ids_desc_only    <- unique(summary_rest$id[summary_rest$diff_vars == "description"])
ids_parking_only <- unique(summary_rest$id[summary_rest$diff_vars == "parking"])
ids_gs_only      <- unique(summary_rest$id[summary_rest$diff_vars == "garageSpaces"])

## Any combo that includes 'time' -> keep the row with the SMALLEST time (most recent)
ids_with_time    <- unique(summary_rest$id[grepl("\\btime\\b", summary_rest$diff_vars)])


keep_idx <- rep(TRUE, nrow(df))

## Rule A: "parking" only -> drop ALL rows for those ids (cannot decide which one is correct)
if (length(ids_parking_only)) {
  keep_idx[df$id %in% ids_parking_only] <- FALSE
}

## Rule B: "description" only -> keep just the first occurrence per id
if (length(ids_desc_only)) {
  w <- df$id %in% ids_desc_only
  keep_idx[w] <- !duplicated(df$id[w])
}

## Rule C: any combo that includes 'time' -> keep the row with the SMALLEST time (most recent)
## - If some times are NA, keep the smallest non-NA; if all are NA, keep the first row.
if (length(ids_with_time)) {
  for (idv in ids_with_time) {
    rows <- which(df$id == idv)
    if (length(rows) >= 2) {
      tvals <- suppressWarnings(as.numeric(df$time[rows]))
      if (all(is.na(tvals))) {
        keep <- rows[1]
      } else {
        # Replace NA with +Inf so they are never the minimum
        t2 <- ifelse(is.na(tvals), Inf, tvals)
        keep <- rows[which.min(t2)]
      }
      keep_idx[rows] <- FALSE
      keep_idx[keep] <- TRUE
    }
  }
}

## Rule D: "garageSpaces" only -> if hasGarage==1 exists, keep the row with garageSpaces==1;
## otherwise keep the first row.
if (length(ids_gs_only)) {
  for (idv in ids_gs_only) {
    rows <- which(df$id == idv)
    if (length(rows) >= 2) {
      gs <- df$garageSpaces[rows]
      hg <- df$hasGarage[rows]
      if (any(hg == 1, na.rm = TRUE) && any(gs == 1 & hg == 1, na.rm = TRUE)) {
        keep <- rows[which((gs == 1) & (hg == 1))[1]]
      } else {
        keep <- rows[1]
      }
      keep_idx[rows] <- FALSE
      keep_idx[keep] <- TRUE
    }
  }
}

df <- df[keep_idx, ]

any(duplicated(df$id))
```

# 2. Data cleaning

## 2.1. Variable analysis

### Initial analysis
```{r}
summary(df)
```
#### Converting categorical variables to factors
```{r}
# Converting characters to factor !!
df[sapply(df, is.character)] <- lapply(df[sapply(df, is.character)], as.factor)

# Converting binary columns (only 0 or 1) to factor
df[sapply(df, function(x) all(na.omit(unique(x)) %in% c(0, 1)))] <- 
  lapply(df[sapply(df, function(x) all(na.omit(unique(x)) %in% c(0, 1)))], as.factor)

summary(df)
```
```{r}
summary(df$livingArea == df$livingAreaValue)
summary(df$livingArea == df$buildingArea)
```

Based on the data summary, several variables were removed due to lack of informational value or redundancy:

- `X.1`, `X`, `id`, and `time` were excluded as they do not provide meaningful information for modeling.
- `stateId`, `state`, `country`, `currency`, and `datePostedString` were removed because they contain no variability: all observations refer to properties in Georgia (USA), use USD, or fall within the same year.
- `hasBadGeocode` was dropped due to having only zero values.
- `is_bankOwned` and `is_forAuction` were excluded due to extremely low variance (each has only one non-zero observation) making them uninformative and potentially noisy.
- `livingAreaValue` and `buildingArea` are exact duplicates of `livingArea` and were removed to avoid redundancy.
- `zipcode` will also be removed, as the information from the city is contained in other variables.
- `latitude` and `longitude` variables do not provide relevant information for the modeling.
- `streetAddress` will be removed as every house contains a different street address. 


### 2.1.1. Target variable: Price
Price is a numerical variable representing the target of the analysis. The histogram reveals a right-skewed distribution. The variable contains no missing values, so imputation is not required. Outlier detection identified 561 mild outliers and 32 extreme outliers, on the higher end of the spectrum. 

```{r}
summary(df$price)
```
```{r}
# Histogram + Normal curve
hist(df$price, breaks = 30, freq = F, main="Histogram of Price", col="cyan")
curve(dnorm(x, mean(df$price), sd(df$price)), add = T)
```
As can be seen in the histogram, the target variable `Price` does not follow a normal distribution. The distribution of `Price` is **right-skewed**, with most values concentrated between approximately 100,000 and 600,000, and a peak around 300,000. This indicates that lower-priced properties are more common, while higher-priced ones are less frequent but still present.

```{r}
# Normal distribution
ks.test(df$price, "pnorm", mean(df$price), sd(df$price))
```
The Kolmogorov-Smirnov test was performed to assess whether the `price` variable follows a normal distribution. The test returned a p-value < 2.2e-16, which is highly significant. Therefore, we reject the null hypothesis of normality and conclude that price does not follow a normal distribution.

```{r}
v <- df$price

# Summary statistics
summary(v)

# Histogram + Normal curve
hist(v, breaks = 30, freq = FALSE, main = "Histogram of Price", xlab = "varname")
curve(dnorm(x, mean(v, na.rm=TRUE), sd(v, na.rm=TRUE)), add = TRUE, col = "red")
```
The skewness suggests the presence of **outliers** or **extreme values** on the higher end, which could affect modeling and should be considered during preprocessing. 

```{r}
# Outliers
# Find the threshold

#UPPER LIMITS
varout <- summary(df$price); varout
iqr <- varout[5] - varout[2]; iqr # diff between IQR = Q3 - Q1
umout <- varout[5] + 1.5*iqr; umout # upper limit to identify mild outliers
usout <- varout[5] + 3*iqr; usout # upper limit to identify extreme outliers

#LOWER LIMITS
varout <- summary(df$price); varout

lmout <- varout[5] - 1.5*iqr; umout # upper limit to identify mild outliers
lsout <- varout[5] - 3*iqr; usout # upper limit to identify extreme outliers

boxplot(df$price, horizontal = T, id=list(labels=row.names(df), n=2))

abline(v=umout,col="orange",lwd=2) # vertical line for mild outliers
abline(v=usout,col="red",lwd=2.5) # vertical line for extreme outliers

abline(v=lmout,col="orange",lwd=2) # vertical line for mild outliers
abline(v=lsout,col="red",lwd=2.5) # vertical line for extreme outliers

mild_outliers <- which(df$price < lmout | df$price > umout)
extreme_outliers <- which(df$price < lsout | df$price > usout)

cat("Number of mild outliers:", length(mild_outliers), "\n")
cat("Number of extreme outliers:", length(extreme_outliers), "\n")

```

### 2.1.2. Numerical variables
#### Variable `pricePerSquareFoot`

```{r}
v <- df$pricePerSquareFoot

# Summary statistics
summary(v)

# Histogram + Normal curve
hist(v, breaks = 30, freq = FALSE, main = "Histogram of pricePerSquareFoot", xlab = "pricePerSquareFoot")
curve(dnorm(x, mean(v, na.rm=TRUE), sd(v, na.rm=TRUE)), add = TRUE, col = "red")
```


```{r}
# Outliers
# Find the threshold

#UPPER LIMITS
varout <- summary(v); varout
iqr <- varout[5] - varout[2]; iqr # diff between IQR = Q3 - Q1
umout <- varout[5] + 1.5*iqr; umout # upper limit to identify mild outliers
usout <- varout[5] + 3*iqr; usout # upper limit to identify extreme outliers

#LOWER LIMITS
varout <- summary(v); varout

lmout <- varout[2] - 1.5*iqr; umout # upper limit to identify mild outliers
lsout <- varout[2] - 3*iqr; usout # upper limit to identify extreme outliers

Boxplot(v, id = list(labels = rownames(df), n = 1),
        main = "Boxplot PricePerSquareFoot")

abline(h=umout,col="orange",lwd=2) # vertical line for mild outliers
abline(h=usout,col="red",lwd=2.5) # vertical line for extreme outliers

abline(h=lmout,col="orange",lwd=2) # vertical line for mild outliers
abline(h=lsout,col="red",lwd=2.5) # vertical line for extreme outliers

mild_outliers <- which(v < lmout | v > umout)
extreme_outliers <- which(v < lsout | v > usout)

cat("Number of mild outliers:", length(mild_outliers), "\n")
cat("Number of extreme outliers:", length(extreme_outliers), "\n")
```
Has one very extreme outlier: preliminary analysis without it.


```{r}
# Delete extreme outlier
df <- df[df$pricePerSquareFoot != 205000, ]
v <- df$pricePerSquareFoot
summary(v)

# Histogram + Normal curve
hist(v, breaks = 30, freq = FALSE, main = "Histogram of pricePerSquareFoot", xlab = "pricePerSquareFoot")
curve(dnorm(x, mean(v, na.rm=TRUE), sd(v, na.rm=TRUE)), add = TRUE, col = "red")
```

```{r}
# Outliers
# Find the threshold

#UPPER LIMITS
varout <- summary(v); varout
iqr <- varout[5] - varout[2]; iqr # diff between IQR = Q3 - Q1
umout <- varout[5] + 1.5*iqr; umout # upper limit to identify mild outliers
usout <- varout[5] + 3*iqr; usout # upper limit to identify extreme outliers

#LOWER LIMITS
varout <- summary(v); varout

lmout <- varout[2] - 1.5*iqr; umout # upper limit to identify mild outliers
lsout <- varout[2] - 3*iqr; usout # upper limit to identify extreme outliers

Boxplot(v, id = list(labels = rownames(df), n = 1),
        main = "Boxplot PricePerSquareFoot")

abline(h=umout,col="orange",lwd=2) # vertical line for mild outliers
abline(h=usout,col="red",lwd=2.5) # vertical line for extreme outliers

abline(h=lmout,col="orange",lwd=2) # vertical line for mild outliers
abline(h=lsout,col="red",lwd=2.5) # vertical line for extreme outliers

mild_outliers <- which(v < lmout | v > umout)
extreme_outliers <- which(v < lsout | v > usout)

cat("Number of mild outliers:", length(mild_outliers), "\n")
cat("Number of extreme outliers:", length(extreme_outliers), "\n")
```
**Observations:**
- 2651: Probable mistake (price ~ 350k/psqft ~ 1100) comparing with similar prices
- 4446, 5080: 2651: Very expensive houses (price and psqft) - maybe not representative?


#### Variable `yearBuilt`

```{r}
v <- df$yearBuilt

# Summary statistics
summary(v)

# Histogram + Normal curve
hist(v, breaks = 30, freq = FALSE, main = "Histogram of yearBuilt", xlab = "yearBuilt")
curve(dnorm(x, mean(v, na.rm=TRUE), sd(v, na.rm=TRUE)), add = TRUE, col = "red")
```
One value (9999) which is NA --> Analysis without it. Cannot likely be imputated.

```{r}
df <- df[df$yearBuilt >= 1799 & df$yearBuilt <= 2025, ]
v <- df$yearBuilt
hist(v, breaks = 30, freq = FALSE, main = "Histogram of yearBuilt", xlab = "yearBuilt")
curve(dnorm(x, mean(v, na.rm=TRUE), sd(v, na.rm=TRUE)), add = TRUE, col = "red")
```

```{r}
v <- df$yearBuilt

# Outliers
# Find the threshold

#UPPER LIMITS
varout <- summary(v); varout
iqr <- varout[5] - varout[2]; iqr # diff between IQR = Q3 - Q1
umout <- varout[5] + 1.5*iqr; umout # upper limit to identify mild outliers
usout <- varout[5] + 3*iqr; usout # upper limit to identify extreme outliers

#LOWER LIMITS
varout <- summary(v); varout

lmout <- varout[2] - 1.5*iqr; umout # upper limit to identify mild outliers
lsout <- varout[2] - 3*iqr; usout # upper limit to identify extreme outliers

Boxplot(v, id = list(labels = rownames(df), n = 10),
        main = "Boxplot yearBuilt")

abline(h=umout,col="orange",lwd=2) # vertical line for mild outliers
abline(h=usout,col="red",lwd=2.5) # vertical line for extreme outliers
abline(h=lmout,col="orange",lwd=2) # vertical line for mild outliers
abline(h=lsout,col="red",lwd=2.5) # vertical line for extreme outliers

mild_outliers <- which(v < lmout | v > umout)
extreme_outliers <- which(v < lsout | v > usout)

cat("Number of mild outliers:", length(mild_outliers), "\n")
cat("Number of extreme outliers:", length(extreme_outliers), "\n")
```
#### Variable `longitude`

```{r}
v <- df$longitude
summary(v)
```
```{r}
# Missing values
sum(is.na(v))
```

```{r}
# Histogram
hist(v, breaks = 30, freq = F, main="Histogram of Longitude", xlab = "Longitude")
curve(dnorm(x, mean(v, na.rm=TRUE), sd(v, na.rm=TRUE)), add = TRUE, col = "red")
```
```{r}
# Outliers
# Find the threshold
varout <- summary(v); varout
iqr <- varout[5] - varout[2]; iqr # diff between IQR = Q3 - Q1
umout <- varout[5] + 1.5*iqr; umout # upper limit to identify mild outliers
usout <- varout[5] + 3*iqr; usout # upper limit to identify extreme outliers
lmout <- varout[5] - 1.5*iqr; umout # upper limit to identify mild outliers
lsout <- varout[5] - 3*iqr; usout # upper limit to identify extreme outliers

Boxplot(v, id = list(labels = rownames(df), n = 20),
        main = "Boxplot longitude")
abline(h=umout,col="orange",lwd=2) # vertical line for mild outliers
abline(h=usout,col="red",lwd=2.5) # vertical line for extreme outliers
abline(h=lmout,col="orange",lwd=2) # vertical line for mild outliers
abline(h=lsout,col="red",lwd=2.5) # vertical line for extreme outliers

mild_outliers <- which(v < lmout | v > umout)
extreme_outliers <- which(v < lsout | v > usout)

cat("Number of mild outliers:", length(mild_outliers), "\n")
cat("Number of extreme outliers:", length(extreme_outliers), "\n")
```

#### Variable `latitude`
```{r}
v <- df$latitude
summary(v)
```
```{r}
# Missing values
sum(is.na(v))
```

```{r}
# Histogram
hist(v, breaks = 30, freq = F, main="Histogram of Latitude", xlab = "Latitude")
curve(dnorm(x, mean(v, na.rm=TRUE), sd(v, na.rm=TRUE)), add = TRUE, col = "red")
```
```{r}
# Outliers
# Find the threshold
varout <- summary(v); varout
iqr <- varout[5] - varout[2]; iqr # diff between IQR = Q3 - Q1
umout <- varout[5] + 1.5*iqr; umout # upper limit to identify mild outliers
usout <- varout[5] + 3*iqr; usout # upper limit to identify extreme outliers
lmout <- varout[5] - 1.5*iqr; umout # upper limit to identify mild outliers
lsout <- varout[5] - 3*iqr; usout # upper limit to identify extreme outliers

Boxplot(v, id = list(labels = rownames(df), n = 10),
        main = "Boxplot latitude")
abline(h=umout,col="orange",lwd=2) # vertical line for mild outliers
abline(h=usout,col="red",lwd=2.5) # vertical line for extreme outliers
abline(h=lmout,col="orange",lwd=2) # vertical line for mild outliers
abline(h=lsout,col="red",lwd=2.5) # vertical line for extreme outliers

mild_outliers <- which(v < lmout | v > umout)
extreme_outliers <- which(v < lsout | v > usout)

cat("Number of mild outliers:", length(mild_outliers), "\n")
cat("Number of extreme outliers:", length(extreme_outliers), "\n")
```


#### Variable `livingArea`

```{r}
v <- df$livingArea
summary(v)
```
```{r}
# Missing values
sum(is.na(v))
```

```{r}
# Histogram
hist(v, breaks = 30, freq = F, main="Histogram of livingArea", xlab = "livingArea")
curve(dnorm(x, mean(v, na.rm=TRUE), sd(v, na.rm=TRUE)), add = TRUE, col = "red")
```
```{r}
# Outliers
# Find the threshold
varout <- summary(v); varout
iqr <- varout[5] - varout[2]; iqr # diff between IQR = Q3 - Q1
umout <- varout[5] + 1.5*iqr; umout # upper limit to identify mild outliers
usout <- varout[5] + 3*iqr; usout # upper limit to identify extreme outliers
lmout <- varout[5] - 1.5*iqr; umout # upper limit to identify mild outliers
lsout <- varout[5] - 3*iqr; usout # upper limit to identify extreme outliers

Boxplot(v, id = list(labels = rownames(df), n = 10),
        main = "Boxplot livingArea")
abline(h=umout,col="orange",lwd=2) # vertical line for mild outliers
abline(h=usout,col="red",lwd=2.5) # vertical line for extreme outliers
abline(h=lmout,col="orange",lwd=2) # vertical line for mild outliers
abline(h=lsout,col="red",lwd=2.5) # vertical line for extreme outliers

mild_outliers <- which(v < lmout | v > umout)
extreme_outliers <- which(v < lsout | v > usout)

cat("Number of mild outliers:", length(mild_outliers), "\n")
cat("Number of extreme outliers:", length(extreme_outliers), "\n")
```
Comparing with the mean price, the extreme outliers have reasonable price in comparison. So, we maintain the extreme outliers. 

#### Variable `bathrooms`: num
Bathroom is a discrete numerical variable. 
```{r}
v <- df$bathrooms
summary(v)
```

```{r}
# Missing values
sum(is.na(df$bathrooms))
```
```{r}
# Histogram
hist(df$bathrooms, breaks = 30, freq = F, main="Histogram of bathrooms", xlab = "bathrooms")
curve(dnorm(x, mean(v, na.rm=TRUE), sd(v, na.rm=TRUE)), add = TRUE, col = "red")
```
As can be seen in the histogram, some observations have 0 bathrooms. Since a house cannot realistically have 0 bathrooms, these values are replaced with NA to indicate missing data and then imputed using the **MICE** algorithm. 

```{r}
# Replace impossible values (0 bathrooms) with NA
v[v == 0] <- NA
# Missing values
sum(is.na(v))
```

After analyzing the advertisements of houses with 9 and 10 bathrooms, we can conclude that they are not outliers but the houses do have that many bathrooms. 


### 2.1.3. Categorical variables

#### Variable `cityId`
```{r}
summary(df$cityId)
```
```{r}
hist(df$cityId, breaks = 30, freq = F)
curve(dnorm(x, mean(df$cityId), sd(df$cityId)), add = T)
```


```{r}
v <- df$cityId

# Frequency table
table(v)

# Barplot
barplot(table(v), main = "Barplot of varname", las = 2, col = "lightblue")
```
```{r}
print(sum(df$cityId == 0))
```
!!!!!!!Variable `cityId` has 297 observations of value 0, also there are some cities that have more than 1 `cityId`, so the relation between `cityId` and `city` is not univocal. 


#### Variable `event`
```{r}
# Frequency table
table(df$event)

# Proportions
prop.table(table(df$event))

# Barplot
barplot(table(df$event), main = "Barplot of event", las = 2, col = "lightblue")
```

#### Variable `city`
```{r}
df$city = factor(df$city)
table(df$city)
```
First, as we see duplicates we unify them into one level. For this, first we put every name to lowercase and then detect the unique levels. 

Strange cases we observe:
* Union Point - Union Pt
* West Point - West Pt
* Avondale Est - Avondale Estates
* Waverly - Waverly Hall

Also, there are several cases of the same name with different capital letters, for example:
* La fayette - La Fayette
* Rock spring - Rock Spring
* Rocky Face - Rocky face
* Talking Rock -  Talking rock
* Trenton - TRENTON
* Warner robins - Warner Robins

```{r}
df$cityf <- tolower(trimws(df$city))
df$cityf[df$cityf == "union pt"] <- "union point"
df$cityf[df$cityf == "west pt"] <- "west point"
df$cityf[df$cityf == "avondale est"] <- "avondale estates"
df$cityf[df$cityf == "waverly hall"] <- "waverly"
table(df$cityf)
df$city <- as.factor(df$cityf) 
```

#### Variable `hasGarage`
```{r}
df$hasGarage = factor(df$hasGarage)
table(df$hasGarage)
barplot(table(df$hasGarage), main = "Barplot of hasGarage", col="pink")
sum(is.na(df$hasGarage))
```

#### Variable `bathrooms`: factor
```{r}
table(df$bathrooms)
```

```{r}
summary(df$bathrooms)
```
```{r}
df$bathrooms = factor(df$bathrooms)
barplot(table(df$bathrooms), main = "Barplot of Bathrooms", col="orange")
```
As can be seen in the barplot, some observations have 0 bathrooms. Since a house cannot realistically have 0 bathrooms, these values are replaced with NA to indicate missing data. Missing values will be later imputed using MICE.  

```{r}
# Replace impossible values (0 bathrooms) with NA
df$bathrooms[df$bathrooms == 0] <- NA
barplot(table(df$bathrooms), main = "Barplot of Bathrooms", col="orange")
sum(is.na(df$bathrooms))
```

#### Variable `parking`
```{r}
v <- df$parking
table(v)
```
```{r}
v = factor(v)
barplot(table(v), main = "Barplot of Parking", col="orange")
```

#### Variable `garageSpaces`
```{r}
v <- df$garageSpaces
table(v)
```

```{r}
summary(v)
```
```{r}
v = factor(v)
barplot(table(v), main = "Barplot of garageSpaces", col="orange")
```
Since higher numbers of garageSpaces have fewer observations, we consider them as 1 level. 

```{r}
df$garageSpaces[df$garageSpaces>=3] <- "3 or more"
df$garageSpaces <- as.factor(df$garageSpaces)
table(df$garageSpaces)
```
```{r}
barplot(table(df$garageSpaces), main = "Barplot of garageSpaces", col="orange")
```

#### Variable `levels`
```{r}
df$levels = factor(df$levels)
table(df$levels)
barplot(table(df$levels), main = "Barplot of levels", col="pink")
sum(is.na(df$levels))
```
We evaluate the number of unique values in the strings to unify them. 
```{r}
unique(df$levels)
```

```{r}
# Standardize text
df$levels <- tolower(df$levels) #Normalize capitalization and remove extra spaces
df$levels <- trimws(df$levels)

# Group similar values
df$levels[df$levels %in% c(
  "one",
  "one-other",
  "one-manufactured home 1 story",
  "one-mobile home 1 story",
  "one-two story foyer",
  "one-two",
  "one-one and one half",
  "one-one and one half-two",
  "manufactured home 1 story",
  "mobile home 1 story"
)] <- "one"

df$levels[df$levels %in% c(
  "0"
)] <- "zero"

df$levels[df$levels %in% c(
  "one and one half",
  "one and one half-split level",
  "one and one half-multi/split",
  "1.5 story",
  "one and one half-two"
)] <- "one and one half"

df$levels[df$levels %in% c(
  "two",
  "two-split foyer",
  "two-split level",
  "two-two story foyer",
  "two-foyer - 2 story",
  "two-three or more",
  "multi/split-two"
)] <- "two"

df$levels[df$levels %in% c(
  "three or more",
  "three or more-two story foyer",
  "3 story",
  "two-three or more",
  "2.5 story",
  "tri level",
  "tri-level",
  "tri level-split level",
  "three or more-split level-tri-level"
)] <- "three or more"

df$levels[df$levels %in% c(
  "multi/split",
  "multi/split-split level",
  "split level",
  "split foyer"
)] <- "multi/split"

df$levels[df$levels %in% c(
  "other-see remarks"
)] <- "other"

# Convert to factor
df$levels <- factor(df$levels,
                    levels = c("one", "one and one half", "two", 
                               "three or more", "multi/split", "other", "zero"))

# Check the result
table(df$levels)
barplot(table(df$levels), main = "Cleaned Levels", col = "lightpink", las = 2)
summary(df$levels)
```
To simplify the levels variable further, the "one and one half" category was reassigned based on its similarity in average price to other groups. After comparing mean prices across levels, it was grouped with "two" to reduce sparsity and improve model interpretability. The same happens with "zero", which was grouped with "one".

```{r}
boxplot(price ~ levels, data = df,
        main = "Price by Level",
        col = "lightblue",
        las = 2)
```
```{r}
# Group similar values
df$levels[df$levels %in% c(
  "0",
  "one",
  "one-other",
  "one-manufactured home 1 story",
  "one-mobile home 1 story",
  "one-two story foyer",
  "one-two",
  "one-one and one half",
  "one-one and one half-two",
  "manufactured home 1 story",
  "mobile home 1 story"
)] <- "one"

df$levels[df$levels %in% c(
  "one and one half",
  "one and one half-split level",
  "one and one half-multi/split",
  "1.5 story",
  "one and one half-two",
  "two",
  "two-split foyer",
  "two-split level",
  "two-two story foyer",
  "two-foyer - 2 story",
  "two-three or more",
  "multi/split-two"
)] <- "two"

df$levels[df$levels %in% c(
  "three or more",
  "three or more-two story foyer",
  "3 story",
  "two-three or more",
  "2.5 story",
  "tri level",
  "tri-level",
  "tri level-split level",
  "three or more-split level-tri-level",
  "multi/split",
  "multi/split-split level",
  "split level",
  "split foyer"
)] <- "three or more"

df$levels[df$levels == "other"] <- NA

# Convert to factor
df$levels <- factor(df$levels,
                    levels = c("one", "two", 
                               "three or more"))

# Check the result
table(df$levels)
barplot(table(df$levels), main = "Cleaned Levels", col = "lightpink", las = 2)
sum(is.na(df$levels))
summary(df$levels)
```

#### Variable `pool`
```{r}
df$pools = factor(df$pool)
table(df$pool)
barplot(table(df$pool), main = "Barplot of pool", col="pink")
sum(is.na(df$pool))
```

#### Variable `spa`
```{r}
df$spa = factor(df$spa)
table(df$spa)
barplot(table(df$spa), main = "Barplot of pool", col="pink")
sum(is.na(df$spa))
```

#### Variable `isNewConstruction`
```{r}
df$isNewConstruction = factor(df$isNewConstruction)
table(df$isNewConstruction)
barplot(table(df$isNewConstruction), main = "Barplot of isNewConstruction", col="pink")
sum(is.na(df$isNewConstruction))
```

#### Variable `hasPetsAllowed`
We see that there's very little houses with pets allowed 51 vs 6041, so we can consider it does not contribute to the model's prediction. We can remove it.
```{r}
df$hasPetsAllowed = factor(df$hasPetsAllowed)
table(df$hasPetsAllowed)
barplot(table(df$hasPetsAllowed), main = "Barplot of hasPetsAllowed", col="pink")
sum(is.na(df$hasPetsAllowed))
```
#### Variable `homeType`
```{r}
df$homeType = factor(df$homeType)
table(df$homeType)
barplot(table(df$homeType), main = "Barplot of homeType", col="pink")
sum(is.na(df$homeType))
```

## Removed variable analysis

In addition to the variables previously discussed, `countyId` (5) and `cityid` (6) were also removed due to inconsistencies, such as multiple codes representing the same city, and `cityid` values equal to 0. 

These variables are redundant, as they simply encode the categorical information already present in `county` and `city`, which are cleaner and more interpretable. 

Also, `longitude` (20) and `latitude` (21) variables are removed because they don't provide relevant information for the model, as they provide spatial information only. 

Variable `hasPetsAllowed` (37) will be removed (diferencia entre factors).


```{r}
# Columns removed after initial analysis
df2 <- df[,-c(1:10, 12, 16, 20:22, 24, 26, 29, 37)]
```

## 2.2. Detection of outliers
### 2.2.1. Univariate outliers


### 2.2.2. Multivariate outliers


## 2.3. Missing values
In the dataset there are missing values in variables:
- 
- 
- 

```{r}
# Imputation: MICE
library(mice)
res.imp <- mice(df2, method = 'pmm', seed=123)
df$bathrooms <- complete(res.imp, 1)$bathrooms
summary(df$bathrooms)
```

# 3. Data transformation
## 3.1. New variable definitions
We create two additional variables: a numeric age variable `n.yearBuilt` and an age factor `f.yearBuilt` as discretisation. 

```{r}
# 1. Numeric age variable
df$n.yearBuilt <- 2025 - df$yearBuilt  

# 2. Age factor variable
df$f.yearBuilt <- cut(df$n.yearBuilt,
                      breaks = c(-Inf, 10, 30, 100, Inf),
                      labels = c("New", "Recent", "Old", "Historic"),
                      right = TRUE)

table(df$f.yearBuilt)
```

We created an additional ordinal variable `f.price` by discretizing the continuous `Price` variable into four quartile-based categories: "Low", "Medium-Low", "Medium-High", and "High". 
```{r}
q <- quantile(df$price, probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE)

df$f.price <- cut(df$price,
                  breaks = q,
                  include.lowest = TRUE,
                  labels = c("Low", "Medium-Low", "Medium-High", "High"))
table(df$f.price)
```


